(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{114:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return o})),t.d(n,"default",(function(){return b}));var a=t(2),r=(t(0),t(215)),l=t(376);const c={title:"Compiler Annotations"},s={id:"advanced/compiler-annotations",title:"Compiler Annotations",description:"To improve translation and compatibility to different Lua interfaces, the TypeScriptToLua transpiler supports several custom annotations that slightly change translation results. This page documents the supported annotations. The syntax of the compiler annotations use the JSDoc syntax.",source:"@site/docs/advanced/compiler-annotations.md",permalink:"/docs/advanced/compiler-annotations",editUrl:"https://github.com/TypeScriptToLua/TypeScriptToLua.github.io/edit/source/docs/advanced/compiler-annotations.md",sidebar:"docs",previous:{title:"Writing Declarations",permalink:"/docs/advanced/writing-declarations"},next:{title:"Functions and the `self` Parameter",permalink:"/docs/advanced/functions-and-the-self-parameter"}},o=[{value:"@compileMembersOnly",id:"compilemembersonly",children:[]},{value:"@customConstructor",id:"customconstructor",children:[]},{value:"@extension",id:"extension",children:[]},{value:"@forRange",id:"forrange",children:[]},{value:"@luaIterator",id:"luaiterator",children:[]},{value:"@luaTable",id:"luatable",children:[]},{value:"@metaExtension",id:"metaextension",children:[]},{value:"@noResolution",id:"noresolution",children:[]},{value:"@noSelf",id:"noself",children:[]},{value:"@noSelfInFile",id:"noselfinfile",children:[]},{value:"@phantom",id:"phantom",children:[]},{value:"@pureAbstract",id:"pureabstract",children:[]},{value:"@tupleReturn",id:"tuplereturn",children:[]},{value:"@vararg",id:"vararg",children:[]}],i={rightToc:o};function b({components:e,...n}){return Object(r.b)("wrapper",Object(a.a)({},i,n,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"To improve translation and compatibility to different Lua interfaces, the TypeScriptToLua transpiler supports several custom annotations that slightly change translation results. This page documents the supported annotations. The syntax of the compiler annotations use the JSDoc syntax."),Object(r.b)("h2",{id:"compilemembersonly"},"@compileMembersOnly"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) enum")),Object(r.b)("p",null,"This decorator removes an enumeration's name after compilation and only leaves its members. Primarily used for APIs with implicit enumerations."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare enum MyEnum {\n  MY_ENUM_MEMBER_A,\n  MY_ENUM_MEMBER_B,\n}\n\nprint(MyEnum.MY_ENUM_MEMBER_A);\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"print(MyEnum.MY_ENUM_MEMBER_A)\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @compileMembersOnly */\ndeclare enum MyEnum {\n  MY_ENUM_MEMBER_A,\n  MY_ENUM_MEMBER_B,\n}\n\nprint(MyEnum.MY_ENUM_MEMBER_A);\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"print(MY_ENUM_MEMBER_A)\n"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example 2")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'enum MyEnum {\n  MY_ENUM_MEMBER_A,\n  MY_ENUM_MEMBER_B,\n  MY_ENUM_MEMBER_C = "c",\n}\n\nprint(MyEnum.MY_ENUM_MEMBER_A);\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'MyEnum = {}\nMyEnum.MY_ENUM_MEMBER_A = 0\nMyEnum.MY_ENUM_MEMBER_B = 1\nMyEnum.MY_ENUM_MEMBER_C = "c"\n\nprint(MyEnum.MY_ENUM_MEMBER_A)\n'))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'/** @compileMembersOnly */\nenum MyEnum {\n  MY_ENUM_MEMBER_A,\n  MY_ENUM_MEMBER_B,\n  MY_ENUM_MEMBER_C = "c",\n}\n\nprint(MyEnum.MY_ENUM_MEMBER_A);\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'MY_ENUM_MEMBER_A = 0\nMY_ENUM_MEMBER_B = 1\nMY_ENUM_MEMBER_C = "c"\n\nprint(MY_ENUM_MEMBER_A)\n'))),Object(r.b)("h2",{id:"customconstructor"},"@customConstructor"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"declare class")),Object(r.b)("p",null,"Changes the way new instances of this class are made. Takes exactly one argument that is the name of the alternative constructor function."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare class MyClass {\n  constructor(x: number);\n}\nconst inst = new MyClass(3);\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"local inst = __TS__New(MyClass, 3)\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @customConstructor MyConstructor */\ndeclare class MyClass {\n  constructor(x: number);\n}\nconst inst = new MyClass(3);\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"local inst = MyConstructor(3)\n"))),Object(r.b)("h2",{id:"extension"},"@extension"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"class")),Object(r.b)("p",null,"The Extension decorator marks a class as an extension of an already existing class. This causes the class header to not be translated, preventing instantiation and the override of the existing class."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"class MyBaseClass {\n  myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"MyBaseClass = __TS__Class()\n...\nfunction MyBaseClass.prototype.myFunction(self) end\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @extension */\nclass MyBaseClass {\n  myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function MyBaseClass.myFunction(self) end\n"))),Object(r.b)("h2",{id:"forrange"},"@forRange"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"declare function")),Object(r.b)("p",null,"Denotes a function declaration is a Lua numerical iterator. When used in a TypeScript ",Object(r.b)("inlineCode",{parentName:"p"},"for...of")," loop, the resulting Lua will use a numerical for loop."),Object(r.b)("p",null,"The function should not be a real function and an error will be thrown if it is used in any other way."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @forRange */\ndeclare function forRange(start: number, limit: number, step?: number): number[];\n\nfor (const i of forRange(1, 10)) {}\nfor (const i of forRange(10, 1, -1)) {}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"for i = 1, 10 do end\nfor i = 10, 1, -1 do end\n"))),Object(r.b)("h2",{id:"luaiterator"},"@luaIterator"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) interface")),Object(r.b)("p",null,"Denotes a type is a Lua iterator. When an object of a type with this annotation is used in a for...of statement, it will transpile directly as a lua iterator in a for...in statement, instead of being treated as a TypeScript iterable. Typically, this is used on an interface that extends ",Object(r.b)("inlineCode",{parentName:"p"},"Iterable")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Array")," so that TypeScript will allow it to be used in a for...of statement."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @luaIterator */\ntype LuaIterable<T> = Iterable<T>;\n\ndeclare function myIterator(): LuaIterable<string>;\nfor (const s of myIterator()) {}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"for s in myIterator() do end\n"))),Object(r.b)("p",null,"This can also be combined with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#tuplereturn"}),"@tupleReturn"),", if the iterator returns multiple values."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'/** @luaIterator @tupleReturn */\ntype LuaTupleIterable<T extends any[]> = Iterable<T>;\n\ndeclare namespace string {\n  function gmatch(s: string, pattern: string): LuaTupleIterable<string[]>;\n}\n\nfor (const [a, b] of string.gmatch("foo", "(.)(.)")) {}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'for a, b in string.gmatch("foo", "(.)(.)") do end\n'))),Object(r.b)("h2",{id:"luatable"},"@luaTable"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"type")),Object(r.b)("p",null,"This annotation signals the transpiler to translate a class as a simple lua table for optimization purposes."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'/** @luaTable */\ndeclare class Table<K extends {} = {}, V = any> {\n  readonly length: number;\n  set(key: K, value: V | undefined): void;\n  get(key: K): V | undefined;\n}\n\nconst tbl = new Table(); // local tbl = {}\n\nconst foo = {};\ntbl.set(foo, "bar"); // tbl[foo] = "bar"\nprint(tbl.get(foo)); // print(tbl[foo])\n\ntbl.set(1, "baz"); // tbl[1] = "baz"\nprint(tbl.length); // print(#tbl)\n')),Object(r.b)("h2",{id:"metaextension"},"@metaExtension"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"class")),Object(r.b)("p",null,"The Extension decorator marks a class as an extension of an already existing meta class/table. This causes the class header to not be translated, preventing instantiation and the override of the existing class."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"class MyBaseClass {\n  myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"MyBaseClass = __TS__Class()\n...\nfunction MyBaseClass.prototype.myFunction(self) end\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @metaExtension */\nclass MyMetaExtension extends MyMetaClass {\n  myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"local __meta__MyMetaClass = debug.getregistry().MyMetaClass\n__meta__MyMetaClass.myFunction = function(self)\nend;\n"))),Object(r.b)("h2",{id:"noresolution"},"@noResolution"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"module")),Object(r.b)("p",null,"Prevents tstl from trying to resolve the module path. When importing this module the path will be exactly the path in the import statement."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'declare module "mymodule" {}\nimport module from "mymodule";\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'...\nlocal module = require("src.mymodule");\n'))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'/** @noResolution */\ndeclare module "mymodule" {}\nimport module from "mymodule";\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'...\nlocal module = require("mymodule");\n'))),Object(r.b)("h2",{id:"noself"},"@noSelf"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"declare class"),", ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) interface")," or ",Object(r.b)("inlineCode",{parentName:"p"},"declare namespace")),Object(r.b)("p",null,"Indicates that functions inside a scope do not take in initial ",Object(r.b)("inlineCode",{parentName:"p"},"self")," argument when called, and thus will be called with a dot ",Object(r.b)("inlineCode",{parentName:"p"},".")," instead of a colon ",Object(r.b)("inlineCode",{parentName:"p"},":"),". It is the same as if each function was declared with an explicit ",Object(r.b)("inlineCode",{parentName:"p"},"this: void")," parameter. Functions that already have an explicit ",Object(r.b)("inlineCode",{parentName:"p"},"this")," parameter will not be affected."),Object(r.b)("p",null,"When applied to a class or interface, this only affects the type's declared methods (including static methods and fields with a function type). It will not affect other function declarations, such as nested functions inside a class' methods."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'declare interface NormalInterface {\n  normalMethod(s: string): void;\n}\ndeclare const x: NormalInterface;\n\n/** @noSelf **/\ndeclare interface NoSelfInterface {\n  noSelfMethod(s: string): void;\n}\ndeclare const y: NoSelfInterface;\n\nx.normalMethod("foo");\ny.noSelfMethod("bar");\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'x:normalMethod("foo")\ny.noSelfMethod("bar")\n'))),Object(r.b)("p",null,"When applied to a namespace, all functions declared within the namespace will treated as if they do not have a ",Object(r.b)("inlineCode",{parentName:"p"},"self")," parameter. In this case, the effect is recursive, so functions in nested namespaces and types declared as parameters will also be affected."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'declare namespace NormalNS {\n  function normalFunc(s: string): string;\n}\n\n/** @noSelf **/\ndeclare namespace NoSelfNS {\n  function noSelfFunc(s: string): string;\n}\n\nNormalNS.normalFunc("foo");\nNoSelfNS.noSelfFunc("bar");\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'NormalNS:normalFunc("foo")\nNoSelfNS.noSelfFunc("bar")\n'))),Object(r.b)("p",null,"For more information about how the ",Object(r.b)("inlineCode",{parentName:"p"},"self")," parameter is handled, see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/advanced/functions-and-the-self-parameter"}),"Functions and the ",Object(r.b)("inlineCode",{parentName:"a"},"self")," Parameter")),Object(r.b)("h2",{id:"noselfinfile"},"@noSelfInFile"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) file")),Object(r.b)("p",null,"Indicates that functions in a file do not take in initial ",Object(r.b)("inlineCode",{parentName:"p"},"self")," argument when called."),Object(r.b)("p",null,"This is annotation works the same as ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#noself"}),"@noSelf")," being applied to a namespace, but affects the entire file."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"@noSelfInFile")," must be placed at the top of the file, before the first statement."),Object(r.b)("h2",{id:"phantom"},"@phantom"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"namespace")),Object(r.b)("p",null,"This decorator marks a namespace as a phantom namespace. This means all members of the namespace will be translated as if they were not in that namespace. Primarily used to prevent scoping issues."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"namespace myNameSpace {\n  function myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"myNameSpace = {}\nfunction myNameSpace.myFunction() end\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @phantom */\nnamespace myNameSpace {\n  function myFunction(): void {}\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function myFunction() end\n"))),Object(r.b)("h2",{id:"pureabstract"},"@pureAbstract"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"declare class")),Object(r.b)("p",null,"This decorator marks a class declaration as purely abstract. The result is that any class extending the purely abstract class will not extend this class in the resulting Lua."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare class MyAbstractClass {}\nclass MyClass extends MyAbstractClass {}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"MyClass = __TS__Class()\nMyClass.__base = MyAbstractClass\nMyClass.____super = MyAbstractClass\nsetmetatable(MyClass, MyClass.____super)\nsetmetatable(MyClass.prototype, MyClass.____super.prototype)\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @pureAbstract */\ndeclare class MyAbstractClass {}\nclass MyClass extends MyAbstractClass {}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"MyClass = __TS__Class()\n"))),Object(r.b)("h2",{id:"tuplereturn"},"@tupleReturn"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) function")),Object(r.b)("p",null,"This decorator indicates a function returns a lua tuple instead of a table. It influences both destructing assignments of calls of that function, as well as changing the format of returns inside the function body."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'function myFunction(): [number, string] {\n  return [3, "4"];\n}\nconst [a, b] = myFunction();\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function myFunction()\n    return {3, "4"}\nend\nlocal a,b = unpack(myFunction())\n'))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),'/** @tupleReturn */\nfunction myFunction(): [number, string] {\n  return [3, "4"];\n}\nconst [a, b] = myFunction();\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function myFunction()\n    return 3, "4"\nend\nlocal a, b = myFunction()\n'))),Object(r.b)("p",null,"If you wish to use this annotation on function with overloads, it must be applied to each signature that requires it."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @tupleReturn */\ndeclare function myFunction(s: string): [string, string];\n/** @tupleReturn */\ndeclare function myFunction(n: number): [number, number];\n")),Object(r.b)("p",null,"Note that if any overloaded signature of a function implementation has the annotation, all array/tuple return values will unpacked in the transpiled output."),Object(r.b)("h2",{id:"vararg"},"@vararg"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Target elements:")," ",Object(r.b)("inlineCode",{parentName:"p"},"(declare) interface or type")),Object(r.b)("p",null,"Indicates that an array-like type represents a Lua vararg expression (",Object(r.b)("inlineCode",{parentName:"p"},"..."),") and should be transpiled to that when used in a spread expression. This is useful for forwarding varargs instead of wrapping them in a table and unpacking them."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"function varargWrapUnpack(...args: string[]) {\n  console.log(...args);\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function varargWrapUnpack(self, ...)\n    local args = ({...})\n    print(unpack(args))\nend\n"))),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @vararg */\ninterface Vararg<T> extends Array<T> {}\n\nfunction varargForward(...args: Vararg<string>) {\n  console.log(...args);\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function varargForward(self, ...)\n    print(...))\nend\n"))),Object(r.b)("p",null,"This can be used to access the file-scope varargs as well."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"declare const arg: Vararg<string>;\nconsole.log(...arg);\nconst [x, y] = [...arg];\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"print(...)\nlocal x, y = ...\n"))),Object(r.b)("p",null,"To also support tuple-typed rest parameters, you can define the type like this:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"/** @vararg */\ntype Vararg<T extends unknown[]> = T & { __luaVararg?: never };\n\nfunction varargForward(...args: Vararg<[string, number]>) {}\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("em",{parentName:"strong"},"Warning"))),Object(r.b)("p",null,"TypeScriptToLua does not check that the vararg expression is valid in the context it is used. If the array is used in a spread operation in an invalid context (such as a nested function), a deoptimization will occur."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)(l.a,{mdxType:"SideBySide"},Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"function outerFunction(...args: Vararg<string>) {\n  function innerFunction() {\n    console.log(...args);\n  }\n  innerFunction();\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"function outerFunction(self, ...)\n    local args = {...}\n    local function innerFunction(self)\n        print(unpack(args))\n    end\n    innerFunction(_G)\nend\n"))))}b.isMDXComponent=!0},215:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return d}));var a=t(0),r=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=r.a.createContext({}),b=function(e){var n=r.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=b(e.components);return r.a.createElement(i.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,i=o(e,["components","mdxType","originalType","parentName"]),p=b(t),m=a,d=p["".concat(c,".").concat(m)]||p[m]||u[m]||l;return t?r.a.createElement(d,s(s({ref:n},i),{},{components:t})):r.a.createElement(d,s({ref:n},i))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,c=new Array(l);c[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,c[1]=s;for(var i=2;i<l;i++)c[i]=t[i];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},376:function(e,n,t){"use strict";t.d(n,"a",(function(){return s}));var a=t(0),r=t.n(a),l=t(377),c=t.n(l);function s({children:e}){const n=r.a.Children.count(e);if(2!==n)throw new Error("Invalid SideBySide children count: "+n);const[t,a]=r.a.Children.toArray(e);return r.a.createElement("div",{className:c.a.sideBySide},t,a)}},377:function(e,n,t){e.exports={sideBySide:"sideBySide_2tt-"}}}]);